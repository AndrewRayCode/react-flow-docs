---
slug: 'react-flow-and-the-web-audio-api'
title: 'Tutorial: Integrating React Flow and the Web Audio API'
authors: ['hayleigh']
tags: ['react-flow', 'web-audio-api', 'how-to']
hide_table_of_contents: false
---

import { AspectRatio } from '@chakra-ui/react';
import CodeViewer from '/src/components/CodeViewer';
import Emoji from '/src/components/Emoji';
import Image from '@theme/IdealImage';
import TabItem from '@theme/TabItem';
import Tabs from '@theme/Tabs';
const editorOptions = { editorHeight: '45vh' };

Today we'll be looking at how to create an interactive audio playground using React
Flow and the Web Audio API. We'll start from scratch, first learning about the Web
Audio API before looking at how to handle many common scenarios in React Flow:
state management, implementing custom nodes, and adding interactivity.

For the most part this tutorial will go step-by-step. We may skip over some bits
here and there, but for the most part if you're new to React Flow you should be
able to follow along and have something working by the end. If you're already a
React Flow pro you might want to read the first section covering the Web Audio
API and then jump to the third to see how things are tied together!

Without further ado...

## A demo!

[Demo flow showcasing everything]

:::caution This and other examples in this tutorial _make sound_.

To avoid creating an avant garde masterpiece, remember to mute each example before
moving on!
:::

## The Web Audio API

Before we get stuck in to React Flow and interactive node editor goodness, we need
to take a crash course on the Web Audio API. Here are the highlights you need to know:

- The Web Audio API provides a variety of different audio nodes, including sources
  (e.g. OscillatorNode, MediaElementAudioSourceNode), effects (e.g. GainNode,
  DelayNode, ConvolverNode), and outputs (e.g. AudioDestinationNode).
- Audio nodes can be connected together to form a (potentially cyclic) graph.
  We tend to call this the audio-processing graph, signal graph, or signal chain.
- Audio processing is handled in a separate thread by native code. This means we
  can keep generating sounds even when the main UI thread is busy or blocked.
- An AudioContext acts as the brain of an audio-processing graph. We can use it
  to create new audio nodes and suspend or resume audio processing entirely.

### Hello, sound!

They say show don't tell but doing is even better so let's see some of this stuff
in action and build our first Web Audio app! We won't be doing anything too wild:
we'll make a simple mouse theramin. We'll use React for these examples and everything
else moving forward (we're called React Flow after all!), but for now you could
use any tech you like including plain HTML and JavaScript.

Start by creating a new AudioContext and putting together the nodes we need. We
want an OscillatorNode to generate some tones and a GainNode to control the volume.

```js
const ctx = new AudioContext();
const osc = ctx.createOscillator();
const amp = ctx.createGain();

osc.connect(amp);
amp.connect(ctx.audioDestination);

osc.start();
```

:::info
Don't forget that call to `osc.start`. The oscillator won't start generating
tones without it!
:::

For our app, we'll track the mouse's position on the screen and use that to set
the pitch of the oscillator node and the volume of the gain node.

```jsx
import React from 'react'

const ctx = new AudioContext()
// ...

const updateValues = (e) => {
  const freq = (e.clientX / window.innerWidth) * 1000
  const gain = e.clientY / window.innerHeight

  osc.frequency.value = freq
  amp.gain.value = gain
}

export default App() {
  return (
    <div style={{ width: '100vw', height: '100vh' }} onMouseMove={updateValues}>

    </div>
  )
}
```

If you try this example as it is, you'll probably find that nothing happens. An
AudioContext often starts in a suspended state in an attempt to avoid ads hijacking
our speakers. We can fix that easily by adding a click handler on the `<div />`
to resume the context if it's suspended.

```jsx
const toggleDSP = () => {
  if (context.state === 'suspended') {
    context.resume()
  } else {
    context.suspend()
  }
}

export default App() {
  return (
    <div ... onClick={toggleDSP}>

    </div>
  )
}
```

:::info DSP stands for "digital signal processing".

`toggleDSP` means "toggle audio processing on or off."
:::

And that's everything we need to start making some sounds with the Web Audio API!
Here's what we put together, in case you weren't following along at home:

[Mouse theramin example]

## Scaffolding a React Flow project

With that done, we can now turn our attention to React Flow and the rest of the
tutorial. Later on we'll take what we've learned about the Web Audio API, oscillators,
and gain nodes and use React Flow to interactively build audio-processing graphs.
For now though, we need to put together an empty React Flow app.

You'll need a little bit of React knowledge to follow along with the rest of this
tutorial. You don't need to be an expert though; the
[quick start guide](https://beta.reactjs.org/learn) should be enough to get you
up to speed.

We'll start by building a fresh React app using `vite`. If you prefer another
bundler like parcel or Create React App that's cool too, they all do basically
the same thing. You could also choose to use TypeScript instead of JavaScript.
To keep things simple we won't use it today, but React Flow is fully typed (and
made in TypeScript) so it's a breeze to use!

```bash
npm create vite@latest -- --template react
```

We only need two additional dependencies for this project: `zustand` as our simple
state management library (that's what we use under the hood at React Flow) and
`nanoid` as a lightweight id generator.

```bash
npm install zustand nanoid
```

Vite will have gone and helpfully scaffolded a little React app for us, but we're
going to go and replace most of it anyway. Go ahead and modify `main.jsx` to
match the following:

```jsx title="./src/main.jsx"
// ðŸ‘‡ Don't forget to import the styles!
import 'reactflow/dist/style.css';
import './index.css';

import App from './App';
import React from 'react';
import ReactDOM from 'react-dom/client';
import { ReactFlowProvider } from 'reactflow';

const root = document.querySelector('#root');

ReactDOM.createRoot(root).render(
  <React.StrictMode>
    <div style={{ width: '100vw', height: '100vh' }}>
      <ReactFlowProvider>
        <App />
      </ReactFlowProvider>
    </div>
  </React.StrictMode>
);
```

There are three important things to pay attention to here:

1. You need to remember to import the React Flow CSS styles to make sure everything
   works correctly.
2. The React Flow renderer needs to be inside an element with a known height and width,
   so we've set the containing `<div />` to take up the entire screen.
3. To use some of the hooks React Flow provides, your components need to be inside a
   `<ReactFlowProvider />` or inside the `<ReactFlow />` component itself, so we've
   wrapped the entire app in the provider to be sure.

Next, hop into `App.jsx` and create an empty flow:

```jsx title="./src/App.jsx"
import React from 'react';
import ReactFlow, { Background } from 'reactflow';

export default function App() {
  return (
    <ReactFlow>
      <Background />
    </ReactFlow>
  );
}
```

We'll expand and add on to this component over time. For now, we've added one of
React Flow's plugins - `<Background />` - to check if everything is setup correctly.
Go ahead and run `npm run dev` (or whatever you need to do to spin up a dev server
if you didn't choose vite) and check out your browser. You should see an empty flow:

[Screenshot of an empty React Flow renderer]

Go ahead and leave the dev server running. We can keep checking back on our progress
as we add new bits and bobs.

### 1. State management with Zustand

A Zustand store will hold all the UI state for our application. In practical terms
that means it'll hold the nodes and edges of our React Flow graph, a few other
pieces of state, and a handful of _actions_ to update that state.

To get a basic interactive React Flow graph going we need three actions:

1. `onNodesChange` to handle nodes being moved around or deleted.
2. `onEdgesChange` to handle _edges_ being moved around or deleted.
3. `addEdge` to connect two nodes in the graph.

Go ahead and create a new file, `store.js`, and add the following:

```js title="./src/store.js"
import { applyNodeChanges, applyEdgeChanges } from 'reactflow';
import { nanoid } from 'nanoid';
import createStore from 'zustand';

export const useStore = createStore((set, get) => ({
  nodes: [],
  edges: [],

  onNodesChange(changes) {
    set({
      nodes: applyNodeChanges(changes, get().nodes),
    });
  },

  onEdgesChange(changes) {
    set({
      edges: applyEdgeChanges(changes, get().edges),
    });
  },

  addEdge(data) {
    const id = nanoid(6);
    const edge = { id, ...data };

    set({ edges: [edge, ...get().edges] });
  },
}));
```

The `changes` arguments represent events like a node or edge being moved or deleted.
Fortunately, React Flow provides some helper functions to apply those changes for
us. We just need to update the store with the new array of nodes.

`addEdge` will be called whenever two nodes get connected. The `data` argument is
_almost_ a valid edge, it's just missing an id. Here we're getting nanoid to
generate a 6 character random id and then adding the edge to our graph, nothing
exciting.

If we hop back over to our `<App />` component we can hook ReactFlow up to our
actions and get something working.

```jsx title="./src/App.jsx"
import React from 'react';
import ReactFlow from 'reactflow';
import shallow from 'zustand/shallow';
import useStore from './store';

const selector = (store) => ({
  nodes: store.nodes,
  edges: store.edges,
  onNodesChange: store.onNodesChange,
  onEdgesChange: store.onEdgesChange,
  addEdge: store.addEdge,
});

export default function App() {
  const store = useStore(selector, shallow);

  return (
    <ReactFlow
      nodes={store.nodes}
      edges={store.edges}
      onNodesChange={store.onNodesChange}
      onEdgesChange={store.onEdgesChange}
      onConnect={store.addEdge}
    >
      <Background />
    </ReactFlow>
  );
}
```

OK that look's a bit weird, what's this `selector` thing all about? Zustand let's
us supply a selector function to pluck out the exact bits of state we need from
the store. Combined with the `shallow` equality function, this means we typically
don't have re-renders when state we don't care about changes.

Right now, our store is small and we actually want everything from it to help
render our React Flow graph, but as we expand on it this selector will make sure
we're not re-rendering _everything_ all the time.

This is everything we need to have an interactive graph: we can move nodes around,
connect them together, and remove them. To demonstrate, _temporarily_ add some
dummy nodes to your store:

```js title="./store.jsx"
const useStore = createStore((set, get) => ({
  nodes: [
    { id: 'a', data: { label: 'oscillator' }, position: { x: 0, y: 0 } },
    { id: 'b', data: { label: 'gain' }, position: { x: 50, y: 50 } },
    { id: 'c', data: { label: 'output' }, position: { x: -50, y: 100 } }
  ],
  ...
}));
```

[Example flow demonstrating a basic but interactive graph]

### 2. Custom nodes

OK great, we have an interactive React Flow instance we can start playing with.
We added some dummy nodes but they're just the default unstyled ones right now.
In this step we'll add three custom nodes with interactive controls: an oscillator
node and controls for the pitch and waveform type, a gain node and a control for
the volume, and an output node and a button to toggle DSP on and off.

Let's create a new folder, `nodes/`, and create a file for each custom node we
want to create. Starting with the oscillator we need two controls and a source
handle to connect the output of the oscillator to other nodes.

```jsx title="./src/nodes/Osc.jsx"
import React from 'react';
import { Handle } from 'reactflow';
import { useStore } from '../store';

export default function Osc({ id, data }) {
  return (
    <div>
      <div>
        <p>Oscillator Node</p>

        <label>
          <input
            className="nodrag"
            type="range"
            min="10"
            max="1000"
            value={data.frequency} />
          <span>{data.frequency}Hz</span>
        </label>

        <label>
          <select className="nodrag" value={data.type}>
            <option value="sine">sine</option>
            <option value="triangle">triangle</option>
            <option value="sawtooth">sawtooth</option>
            <option value="square">square</square>
          </select>
      </div>

      <Handle type="source" />
    </div>
  )
}
```

:::info "nodrag" is important.

Pay attention to the `"nodrag"` class being added to both the `<input />` and
`<select />` elements. It's _super important_ that you remember to add this class
otherwise you'll find that React Flow intercepts the mouse events and you'll be
stuck dragging the node around forever!
:::

If we try rendering this custom node we'll find that the inputs don't do anything.
That's because the input values are fixed by `data.frequency` and `data.type` but
we have no event handlers listening to changes and no mechanism to update a node's
data!

To fix the situation we need to jump back to our store and add an `updateNode` action:

```js title="./src/store.js"
import { applyNodeChanges, applyEdgeChanges } from 'reactflow';
import { nanoid } from 'nanoid';
import createStore from 'zustand';

export const useStore = createStore((set, get) => ({
  ...

  updateNode(id, data) {
    set({
      nodes: get().nodes.map(node =>
        node.id === id
          ? { ...node, data: Object.assign(node.data, data) }
          : node
      )
    })
  },

  ...
}));
```

This action will handle partial data updates, so if we only want to update a
node's `frequency`, for example, we could just call `updateNode(id, { frequency: 220 }`.
Now we just need to pull the action into our `<Osc />` component and call it
whenever an input changes.

```jsx title="./src/nodes/Osc.jsx
import React from 'react';
import { Handle } from 'reactflow';
import shallow from 'zustand/shallow';
import { useStore } from '../store';

const selector = (id) => (store) => ({
  setFrequency: (e) => store.updateNode(id, { frequency: +e.target.value }),
  setType: (e) => store.updateNode(id, { type: e.target.value }),
});

export default function Osc({ id, data }) {
  const { setFrequency, setType } = useStore(selector(id), shallow);

  return (
    <div>
      <div>
        <p>Oscillator Node</p>

        <label>
          <input
            className="nodrag"
            type="range"
            min="10"
            max="1000"
            value={data.frequency}
            onChange={setFrequency}
          />
          <span>{data.frequency}Hz</span>
        </label>

        <label>
          <select className="nodrag" value={data.type} onChange={setType}>
            <option value="sine">sine</option>
            <option value="triangle">triangle</option>
            <option value="sawtooth">sawtooth</option>
            <option value="square">square</option>
          </select>
        </label>
      </div>

      <Handle type="source" />
    </div>
  );
}
```

Hey, that `selector` is back! Notice how this time we're using it to derive
two event handlers, `setFrequency` and `setType`, from the general `updateNode`
action.

The last piece of the puzzle is to tell React Flow how to render our custom node.
For that we need to create a `nodeTypes` object: the keys should correspond to a
node's `type` and the value will be the React component to render.

```jsx title"./src/App.jsx"
import React from 'react';
import ReactFlow from 'reactflow';
import shallow from 'zustand/shallow';
import useStore from './store';
import Osc from './nodes/Osc';

const selector = (store) => ({
  nodes: store.nodes,
  edges: store.edges,
  onNodesChange: store.onNodesChange,
  onEdgesChange: store.onEdgesChange,
  addEdge: store.addEdge,
});

const nodeTypes = {
  osc: Osc,
};

export default function App() {
  const store = useStore(selector, shallow);

  return (
    <ReactFlow
      nodes={store.nodes}
      nodeTypes={nodeTypes}
      edges={store.edges}
      onNodesChange={store.onNodesChange}
      onEdgesChange={store.onEdgesChange}
      onConnect={store.addEdge}
    >
      <Background />
    </ReactFlow>
  );
}
```

:::info Avoid unecessary renders.
It's important to define `nodeTypes` outside of the `<App />` component (or use
React's `useMemo`) to avoid recomputing it ever render.
:::

If you've got the dev server running, don't panic if things haven't changed yet!
None of our temporary nodes have been given the right type yet, so React Flow
just falls back to rendering the default node. If we change one of those nodes to
be an `osc` with some initial values for `frequency` and `type` we should see
our custom node being rendered.

```js title"./src/store.js"
const useStore = createStore((set, get) => ({
  nodes: [
    { type: 'osc',
      id: 'a',
     Â data: { frequency: 220, type: 'square' },
     Â position: { x: 0, y: 0 }
    },
    ...
  ],
  ...
}));
```

[An example flow demoing a custom oscillator node]

Implementing a gain node is pretty much the same process, so we'll leave that one
down to you. Instead, we'll turn our attention to the output node. This node we
have no parameters control, but we do want to toggle signal processing on and off.
That's a bit difficult right now when we haven't implemented any audio code yet,
so in the meantime we'll add a just flag to our store and an action to toggle it.

```js title="./src/store.js"
const useStore = createStore((set, get) => ({
  ...

  isRunning: false,

  toggleAudioProcessing() {
    set({ isRunning: !get().isRunning })
  },

  ...
}));
```

The custom node itself is then pretty simple:

```jsx title="./src/nodes/Out.jsx"
import React from 'react';
import { Handle } from 'reactflow';
import shallow from 'zustand/shallow';
import { useStore } from '../store';

const selector = (store) => ({
  isRunning: store.isRunning,
  toggleAudioProcess: store.toggleAudioProcessing,
});

export default function Out({ id, data }) {
  const { isRunning, toggleAudioProcessing } = useStore(selector, shallow);

  return (
    <div>
      <Handle type="source" />

      <div>
        <p>Output Node</p>

        <button onClick={toggleAudioProcessing}>
          {isRunning ? (
            <span role="img" aria-label="mute">
              ðŸ”‡
            </span>
          ) : (
            <span role="img" aria-label="unmute">
              ðŸ”ˆ
            </span>
          )}
        </button>
      </div>
    </div>
  );
}
```

If we add a lick of paint to everything, things are shaping up quite nicely!

[Demo flow showcasing styled custom nodes but no audio code]

The next step, then, is toâ€¦

## Do sound to it

We have an interactive graph and we're able to update node data, now let's add
in what we know about the Web Audio API. Start by creating a new file, `audio.js`,
and create a new audio context and an empty `Map`.

```js title="./src/audio.js"
const context = new AudioContext();
const nodes = new Map();
```

The way we'll manage our audio graph is by hooking into the different actions in
our store. So we might connect two audio nodes when the `addEdge` action is called,
or update an audio node's properties when `updateNode` is called, and so on.

### 1. Node changes

Right now, there are two types of node changes that can happen in our graph and
that we need to respond to: updating a node's `data`, and removing a node from the
graph. We already have an action for the former, so let's handle that first.

In `audio.js` we'll define a function, `updateAudioNode`, that we'll call with a
node's id and a partial `data` object and use it to update an existing node in
the `Map`:

```js title="./src/audio.js"
export function updateAudioNode(id, data) {
  const node = nodes.get(id);

  for (const [key, val] of Object.entries(data)) {
    if (node[key] instanceof AudioParam) {
      node[key].value = val;
    } else {
      node[key] = val;
    }
  }
}
```

:::info
Remember that properties on an audio node may be special `AudioParams` that
must be updated differently to regular object properties.
:::

Now we'll want to update our `updateNode` action in the store to call this function
as part of the update:

```js title="./src/store.js"
import { updateAudioNode } from './audio'

export const useStore = createStore((set, get) => ({
  ...

  updateNode(id, data) {
    updateAudioNode(id, data)
    set({ nodes: ... })
  },

  ...
}));

```

The next change we need to handle is removing a node from the graph. If you select
a node in the graph and hit backspace, React Flow will remove it. This is implicitly
handled for us by the `onNodesChange` action we hooked up, but now we want some
additional handling we'll need to wire up a new action to React Flow's `onNodesDelete`
event.

This is actually pretty simple, so I'll save you some reading and present the next
three snippets of code without comment.

<Tabs>
  <TabItem value="audio.js" label="audio.js" default>

```js
export function removeAudioNode(id) {
  const node = nodes.get(id);

  node.disconnect();
  node.stop?.();

  nodes.delete(id);
}
```

  </TabItem>
  <TabItem value="store.js" label="store.js">

```js
import { ..., removeAudioNode } from './audio'

export const useStore = createStore((set, get) => ({
  ...

  removeNodes(nodes) {
    for (const { id } of nodes) {
      removeAudioNode(id)
    }
  },

  ...
}));
```

  </TabItem>
  <TabItem value="App.jsx" label="App.jsx">

```jsx
const selector = store => ({
  ...,
  onNodesDelete: store.removeNodes
})

export default function App() {
  const store = useStore(selector, shallow)

  return (
    <ReactFlow
      onNodesDelete={store.onNodesDelete}
      ...
    >
      <Background />
    </ReactFlow>
  )
}
```

  </TabItem>
</Tabs>

The only thing to note is that `onNodesDelete` calls the provided callback with
an _array_ of deleted nodes, because it is possible to delete more than one node
at once!

### 2. Edge changes

We're tantalisingly close to actually making some sounds! All that's left is to
handle changes to our graph's edges. Like with node changes, we already have an
action to handle creating new edges and we're also implicitly handling removed
edges in `onEdgesChange`.

To handle new connections, we just need the `source` and `target` ids from the
edge created in our `addEdge` action. Then we can just look up the two nodes in
our `Map` and connect them up.

<Tabs>
  <TabItem value="./src/audio.js" label="./src/audio.js" default>

```js
export function connect(sourceId, targetId) {
  const source = nodes.get(sourceId);
  const target = nodes.get(targetId);

  source.connect(target);
}
```

  </TabItem>
  <TabItem value="./src/store.js" label="./src/store.js">

```js
import { ..., connect } from './audio'

export const useStore = createStore((set, get) => ({
  ...

  addEdge(data) {
    ...

    connect(data.source, data.target)
  },

  ...
}));
```

  </TabItem>
</Tabs>

We saw React Flow accepted an `onNodesDelete` handler and wouldn't you know it,
there's an `onEdgesDelete` handler too! The approach we'd take to implement `disconnect`
and hook it up to our store and React Flow instance is pretty much the same as
before, so we'll leave that one down to you as well!

### 3. Switching the speakers on

You'll remember that our `AudioContext` probably begins in a suspended state to
prevent potentially annoying autoplay issues. We already faked the data and actions
we need for our `<Out />` component in the store, now we just need to replace
them with the real context's state and resume/suspend methods.

```js title="./src/audio.js"
export function isRunning() {
  return context.state === 'running';
}

export function toggleAudioProcessing() {
  return isRunning() ? context.suspend() : context.resume();
}
```

Although we haven't been returning anything from our audio functions up until now,
we need to return from `toggleAudioProcessing` because those methods are
asynchronous and we don't want to update the store prematurely!

```js title="./src/store.js"
import { ..., isRunning, toggleAudioProcessing } from './audio'

export const useStore = createStore((set, get) => ({
  ...

  isRunning: isRunning(),

  toggleAudioProcessing() {
    toggleAudioProcessing().then(() => {
      set({ isRunning: isRunning() })
    })
  }
}));
```

Et voilÃ , we did it! We've now put enough together to actually _make sounds_!
Let's see what we have in action.

[Demo flow showcasing a hardcoding graph producing real-time audio]

### 4. Creating new nodes

Up until now we have been dealing with a hard-coded set of nodes in our graph.
This has been fine for prototyping but for it to actually be useful we'll want a
way to add new nodes to the graph dynamically. Our final task will be adding this
functionality: we'll work backwards starting with the audio code and ending by
creating a basic toolbar.

Implementing a `createAudioNode` function will be simple enough. All we need is
an id for the new node, the type of node to create, and its initial data:

```js title="./src/audio.js"
export function createAudioNode(id, type, data) {
  switch (type) {
    case 'osc': {
      const node = context.createOscillator();
      node.frequency.value = data.frequency;
      node.type = data.type;
      node.start();

      nodes.set(id, node);
      break;
    }

    case 'amp': {
      const node = context.createGain();
      node.gain.value = data.gain;

      nodes.set(id, node);
      break;
    }
  }
}
```

## Final thoughts

Whew that was a long one, but we made it! For our efforts we've come out the other
side with a fun little interactive audio playground, learned a little bit about
the Web Audio API along the way, and have a better idea of one approach to "running"
